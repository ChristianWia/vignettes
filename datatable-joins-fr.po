#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: Christian Wiat <w9204-rs@yahoo.com>\n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fr\n"
"X-Generator: Poedit 2.4.2\n"

#: datatable-joinsMA695.Rmd:block 1 (header)
msgid ""
"title: \"Joins in data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"markdown::html_format\n"
"vignette: >\n"
"%\\VignetteIndexEntry{Joins in data.table}\n"
"%\\VignetteEngine{knitr::knitr}\n"
"\\usepackage[utf8]{inputenc}\n"
"editor_options:\n"
"chunk_output_type: console"
msgstr ""
"title: \"Jointures avec data.table\"\n"
"date: \"`r Sys.Date()`\"\n"
"output:\n"
"markdown::html_format\n"
"vignette: >\n"
"%\\VignetteIndexEntry{Joins in data.table}\n"
"%\\VignetteEngine{knitr::knitr}\n"
"\\usepackage[utf8]{inputenc}\n"
"editor_options:\n"
"chunk_output_type: console"

#: datatable-joinsMA695.Rmd:block 3 (paragraph)
msgid ""
"In this vignette you will learn how to perform any join operation using "
"resources available in the `data.table` syntax."
msgstr ""
"Dans cette vignette nous apprendrons à réaliser les opérations de jointure "
"en utilisant les ressources de la syntaxe `data.table`."

#: datatable-joinsMA695.Rmd:block 4 (paragraph)
msgid ""
"It assumes familiarity with the `data.table` syntax. If that is not the "
"case, please read the following vignettes:"
msgstr ""
"Cela suppose que vous êtes déjà familiarisé avec la syntaxe `data.table` . "
"Si ce n'est pas le cas, reportez-vous aux vignettes suivantes :"

#: datatable-joinsMA695.Rmd:block 5 (unordered list)
msgid "`vignette(\"datatable-intro\", package=\"data.table\")`"
msgstr "`vignette(\"datatable-intro\", package=\"data.table\")`"

#: datatable-joinsMA695.Rmd:block 5 (unordered list)
msgid "`vignette(\"datatable-reference-semantics\", package=\"data.table\")`"
msgstr "`vignette(\"datatable-reference-semantics\", package=\"data.table\")`"

#: datatable-joinsMA695.Rmd:block 5 (unordered list)
msgid "`vignette(\"datatable-keys-fast-subset\", package=\"data.table\")`"
msgstr "`vignette(\"datatable-keys-fast-subset\", package=\"data.table\")`"

#: datatable-joinsMA695.Rmd:block 6 (header)
msgid "1. Defining example data"
msgstr "1. Définissons nos données d'exemple"

#: datatable-joinsMA695.Rmd:block 7 (paragraph)
msgid ""
"To illustrate how to use the method available with real life examples, "
"let's simulate a **normalized database** from a little supermarket by "
"performing the following steps:"
msgstr ""
"Pour illustrer la méthode proposée avec des exemples de la vie courante, "
"nous allons simuler une **base de données normalisée** à partir d'un petit "
"supermarché en réalisant les étapes suivantes :"

#: datatable-joinsMA695.Rmd:block 8 (ordered list)
msgid ""
"Defining a `data.table` where each product is represented by a row with "
"some qualities, but leaving one product without `id` to show how the "
"framework deals with ***missing values***."
msgstr ""
"Définir une `data.table` où chaque produit est représenté par une ligne "
"avec quelques attributs, mais en laissant un produit sans `id` pour montrer "
"comment d'environnement réagit avec les ***valeurs absentes***."

#: datatable-joinsMA695.Rmd:block 10 (ordered list)
msgid ""
"Defining a `data.table` showing the proportion of taxes to be applied for "
"processed products based on their units."
msgstr ""
"Définir une `data.table` donnant le pourcentage des taxes à appliquer aux "
"produits traités en fonction de leurs unités."

#: datatable-joinsMA695.Rmd:block 12 (ordered list)
msgid ""
"Defining a `data.table` simulating the products received every Monday with "
"a `product_id` that is not present in the `Products` table."
msgstr ""
"Définir une `data.table` simulant les produits reçus chaque lundi avec des "
"`product_id` non présents dans la table `Products` ."

#: datatable-joinsMA695.Rmd:block 14 (ordered list)
msgid ""
"Defining a `data.table` to show some sales that can take place on weekdays "
"with another `product_id` that is not present in the `Products` table."
msgstr ""
"Définir une `data.table` pour afficher des promotions certains jours de la "
"semaine avec un autre `product_id` qui n'est pas dans la table `Products` ."

#: datatable-joinsMA695.Rmd:block 16 (header)
msgid "2. `data.table` joining syntax"
msgstr "2. Syntaxe le la jointure `data.table`"

#: datatable-joinsMA695.Rmd:block 17 (paragraph)
msgid ""
"Before taking advantage of the `data.table` syntax to perform join "
"operations we need to know which arguments can help us to perform "
"successful joins."
msgstr ""
"Avant de voir les avantages de la syntaxe `data.table` pour faire des "
"opérations de jointure nous devons savoir quels arguments peuvent nous "
"aider à les réaliser avec succès."

#: datatable-joinsMA695.Rmd:block 18 (paragraph)
msgid ""
"The next diagram shows a description for each basic argument. In the "
"following sections we will show how to use each of them and add more "
"complexity little by little."
msgstr ""
"The next diagram shows a description for each basic argument. In the "
"following sections we will show how to use each of them and add more "
"complexity little by little."

#: datatable-joinsMA695.Rmd:block 20 (quote)
msgid ""
"Please keep in mind that the standard argument order in data.table is "
"`dt[i, j, by]`. For join operations, it is recommended to pass the `on` and "
"`nomatch` arguments by name to avoid using `j` and `by` when they are not "
"needed."
msgstr ""
"N'oubliez pas que l'ordre standard des arguments dans data.table est `dt[i, "
"j, by]`. Pour les opérations de jointure, il est recommandé de passer les "
"arguments `on` et `nomatch` par nom pour éviter d'utiliser `j` et `by` "
"quand ce n'est pas nécessaire."

#: datatable-joinsMA695.Rmd:block 21 (header)
msgid "3. Equi joins"
msgstr "3. Jointures équilibrées"

#: datatable-joinsMA695.Rmd:block 22 (paragraph)
msgid ""
"This the most common and simple case as we can find common elements between "
"tables to combine."
msgstr ""
"C'est le cas général et facile où il y a des éléments communs entre les "
"tables à combiner."

#: datatable-joinsMA695.Rmd:block 23 (paragraph)
msgid "The relationship between tables can be:"
msgstr "La relation entre les tables peut être :"

#: datatable-joinsMA695.Rmd:block 24 (unordered list)
msgid "**One to one**: When each matching value is unique on each table."
msgstr ""
"**De un à un**: lorsque chaque valeur sélectionnée est unique dans chaque "
"table."

#: datatable-joinsMA695.Rmd:block 24 (unordered list)
msgid ""
"**One to many**: When some matching values are repeated in one of the table "
"both unique in the other one."
msgstr ""
"**De un à plusieurs** : lorsque certaines valeurs sélectionnées sont "
"répétées dans une table et à la fois uniques dans l'autre."

#: datatable-joinsMA695.Rmd:block 24 (unordered list)
msgid ""
"**Many to many**: When the matching values are repeated several times on "
"each table."
msgstr ""
"**De plusieurs à plusieurs** : lorsque les valeurs sélectionnées sont "
"répétées plusieurs fois dans chaque table."

#: datatable-joinsMA695.Rmd:block 25 (paragraph)
msgid ""
"In most of the following examples we will perform *one to many* matches, "
"but we are also going to take the time to explain the resources available "
"to perform *many to many* matches."
msgstr ""
"Dans laplupart des exemples suivants nous réaliserons des correspondances "
"*un vers plusieurs* , mais nous prendrons aussi le temps d'expliquer les "
"ressources disponibles pour réaliser les correspondances *de plusieurs vers "
"plusieurs* ."

#: datatable-joinsMA695.Rmd:block 26 (header)
msgid "3.1. Right join"
msgstr "3.1. Jointure droite"

#: datatable-joinsMA695.Rmd:block 27 (paragraph)
msgid ""
"Use this method if you need to combine columns from 2 tables based on one "
"or more references but ***keeping all rows present in the table located on "
"the right (in the the square brackets)***."
msgstr ""
"Utilisez cette méthode pour combiner les colonnes de deux tables en se "
"basant sur une ou plusieurs références mais ***en gardant toutes les lignes "
"présentes dans la table située à droite (entre crochets)***."

#: datatable-joinsMA695.Rmd:block 28 (paragraph)
msgid ""
"In our supermarket context, we can perform a right join to see more details "
"about the products received as this is relation *one to many* by passing a "
"vector to the `on` argument."
msgstr ""
"Dans le contexte de notre supermarché nous pouvons réaliser une jointure "
"droite pour voir davantage de détails à propos des produits reçus parce que "
"c'est une relation de *un vers plusieurs* en passant un vecteur dans "
"l'argument `on`."

#: datatable-joinsMA695.Rmd:block 30 (paragraph)
msgid ""
"As many things have changed, let's explain the new characteristics in the "
"following groups:"
msgstr ""
"Comme beaucoup de choses ont changé, nous allons expliquer les nouvelles "
"caractéristiques dans les groupes suivants :"

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid "**Column level**"
msgstr "**Niveau colonne**"

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid ""
"The *first group* of columns in the new data.table comes from the `x` table."
msgstr ""
"Le *premier groupe* de colonnes dans le nouveau data.table vient de la "
"table `x` ."

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid ""
"The *second group* of columns in the new data.table comes from the `i` "
"table."
msgstr ""
"Le *second groupe* de colonnes de la nouvelle data.table vient de la table "
"`i`."

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid ""
"If the join operation presents a present any **name conflict** (both table "
"have same column name) the ***prefix*** `i.` is added to column names from "
"the **right-hand table** (table on `i` position)."
msgstr ""
"Si l'opération de jointure fait apparaître un **conflit de nom** (les deux "
"tables ont le même nom de colonne) le ***prefixe*** `i.` est ajouté aux "
"noms des colonnes de la **table de droite** (table en position `i`)."

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid "**Row level**"
msgstr "**Niveau ligne**"

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid ""
"The missing `product_id` present on the `ProductReceived` table in row 1 "
"was successfully matched with missing `id` of the `Products` table, so `NA` "
"***values are treated as any other value***."
msgstr ""
"Le `product_id` qui est absent, mais présent dans la table "
"`ProductReceived` à la ligne 1 a été sélectionné avec le `id` absent de la "
"table `Products`, donc ***les valeurs `NA` sont traitées comme les autres "
"valeurs***."

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid "All rows from in the `i` table were kept including:"
msgstr "Toutes les lignes de la table `i` ont été gardées y compris :"

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid "Not matching rows like the one with `product_id = 6`."
msgstr ""
"Les lignes qui ne correspondent pas, comme celle avec `product_id = 6`."

#: datatable-joinsMA695.Rmd:block 31 (unordered list)
msgid "Rows that repeat the same `product_id` several times."
msgstr "Lignes qui répètent les même `product_id` plusieurs fois."

#: datatable-joinsMA695.Rmd:block 32 (header)
msgid "3.1.1. Joining by a list argument"
msgstr "3.1.1. Jointure avec un argument de liste"

#: datatable-joinsMA695.Rmd:block 33 (paragraph)
msgid ""
"If you are following the vignette, you might have found out that we used a "
"vector to define the relations between tables in the `on` argument, that is "
"really useful if you are **creating your own functions**, but another "
"alternative is to use a **list** to define the columns to match."
msgstr ""
"Si vous suivez la vignette, vous avez pu voir que nous avons utilisé un "
"vecteur pour définir les relations entre les tables dans l'argument `on`, "
"ce qui réellement utile si vous **créez vos propres fonctions**, mais une "
"autre alternative est d'utiliser une **liste** pour définir les colonnes à "
"sélectionner. "

#: datatable-joinsMA695.Rmd:block 34 (paragraph)
msgid "To use this capacity, we have 2 equivalent alternatives:"
msgstr ""
"Pour utiliser cette capacité, nous avons a disposition les alternatives "
"suivantes :"

#: datatable-joinsMA695.Rmd:block 35 (unordered list)
msgid "Wrapping the related columns in the base R `list` function."
msgstr "Inclure les colonnes associées dans la fonction R de base `list` ."

#: datatable-joinsMA695.Rmd:block 37 (unordered list)
msgid "Wrapping the related columns in the data.table `list`alias `.`."
msgstr "Inclure les colonnes associées dans la data.table `list`alias `.`."

#: datatable-joinsMA695.Rmd:block 39 (header)
msgid "3.1.2. Alternatives to define the `on` argument"
msgstr "3.1.2. Alternatives pour définir l'argument `on`"

#: datatable-joinsMA695.Rmd:block 40 (paragraph)
msgid ""
"In all the prior example we have pass the column names we want to match to "
"the `on` argument but `data.table` also have alternatives to that syntax."
msgstr ""
"Dans tous les exemples précédents, nous avons passé les noms des colonnes à "
"sélectionner avec l'argument `on` mais `data.table` possède également des "
"alternatives à cette syntaxe."

#: datatable-joinsMA695.Rmd:block 41 (unordered list)
msgid ""
"**Natural join**: Selects the columns to perform the match based on common "
"column names. To illustrate this method, let's change the column of "
"`Products` table from `id` to `product_id` and use the keyword `.NATURAL`."
msgstr ""
"**Jointure naturelle**: sélectionne les colonnes pour réaliser la "
"correspondance en fonction des noms des colonnes communes. Pour illustrer "
"cette méthode, modifions la colonne de la table `Products` de `id` en "
"`product_id` et utilisons le mot clé `.NATURAL`."

#: datatable-joinsMA695.Rmd:block 43 (unordered list)
msgid ""
"**Keyed join**: Selects the columns to perform the match based on keyed "
"columns regardless of their names.To illustrate this method, we need to "
"define keys in the same order for both tables."
msgstr ""
"**Jointure par clé**: sélectionne les colonnes pour rechercher la "
"correspondance  en fonction des colonnes clé quelque soit leur nom. Pour "
"illustrer cette méthode, nous devons définir les clés dans le même ordre "
"pour les deux tables."

#: datatable-joinsMA695.Rmd:block 45 (header)
msgid "3.1.3. Operations after joining"
msgstr "3.1.3. Opérations après la jointure"

#: datatable-joinsMA695.Rmd:block 46 (paragraph)
msgid ""
"Most of the time after a join is complete we need to make some additional "
"transformations. To make so we have the following alternatives:"
msgstr ""
"La plupart du temps après avoir terminé une jointure nous souhaitons faire "
"des adaptations supplémentaires. Pour cela plusieurs alternatives vous sont "
"proposées :"

#: datatable-joinsMA695.Rmd:block 47 (unordered list)
msgid "Chaining a new instruction by adding a pair of brakes `[]`."
msgstr ""
"Chaîner une nouvelle instruction en ajoutant une paire de crochets `[]`."

#: datatable-joinsMA695.Rmd:block 47 (unordered list)
msgid ""
"Passing a list with the columns that we want to keep or create to the `j` "
"argument."
msgstr ""
"En passant comme argument `j` une liste des colonnes que l'on veut "
"conserver ou créer."

#: datatable-joinsMA695.Rmd:block 48 (paragraph)
msgid ""
"Our recommendation is to use the second alternative if possible, as it is "
"**faster** and uses **less memory** than the first one."
msgstr ""
"Notre recommendation est d'utiliser la seconde alternative si possible, car "
"elle est **plus rapide** et demande **moins de mémoire** que la première."

#: datatable-joinsMA695.Rmd:block 49 (header)
msgid "Managing shared column Names with the j argument"
msgstr "Gestion de la colonne partagée Names avec l'argument j"

#: datatable-joinsMA695.Rmd:block 50 (paragraph)
msgid ""
"The `j` argument has great alternatives to manage joins with tables "
"**sharing the same names for several columns**. By default all columns are "
"taking their source from the the `x` table, but we can also use the `x.` "
"prefix to make clear the source and use the prefix `i.` to use any column "
"form the table declared in the `i` argument of the `x` table."
msgstr ""
"L'argument `j` autorise plusieurs alternatives intéressantes pour gérer les "
"jointures avec les tables en **partageant les mêmes noms de plusieurs "
"colonnes**. Par défaut toutes les colonnes prennent leur source dans la "
"table `x`, mais nous pouvons aussi utiliser le préfixe `x.` pour clarifier "
"la source et utiliser le préfixe `i.` pour toutes les colonnes de la table "
"déclarée dans l'argument `i` de la table `x`."

#: datatable-joinsMA695.Rmd:block 51 (paragraph)
msgid ""
"Going back to the little supermarket, after updating the `ProductReceived` "
"table with the `Products` table, it seems convenient apply the following "
"changes:"
msgstr ""
"Si nous retournons au petit supermarché, après avoir mis à jour la table "
"`ProductReceived` avec la table `Products` , il semble pratique d'appliquer "
"les modifications suivantes :"

#: datatable-joinsMA695.Rmd:block 52 (unordered list)
msgid ""
"Changing the columns names from `id` to `product_id` and from `i.id` to "
"`received_id`."
msgstr ""
"Modifier le nom des colonnes de `id` en `product_id` et de `i.id` en "
"`received_id`."

#: datatable-joinsMA695.Rmd:block 52 (unordered list)
msgid "Adding the `total_value`."
msgstr "Ajout de `total_value`."

#: datatable-joinsMA695.Rmd:block 54 (header)
msgid "Summarizing with on in data.table"
msgstr "Résumé avec on dans data.table"

#: datatable-joinsMA695.Rmd:block 55 (paragraph)
msgid ""
"We can also use this alternative to return aggregated results based columns "
"present in the `x` table."
msgstr ""
"Nous pouvons aussi utiliser cette alternative pour renvoyer les résultats "
"agrégés enn fonction des colonnes présentes dans la table `x` ."

#: datatable-joinsMA695.Rmd:block 56 (paragraph)
msgid ""
"For example, we might interested in how much money we expend buying "
"products each date regardless the products."
msgstr ""
"Par exemple on pourrait s'intéresser à combien on dépense à acheter des "
"produits à chaque date quelque soit ces produits."

#: datatable-joinsMA695.Rmd:block 58 (header)
msgid "3.1.4. Joining based on several columns"
msgstr "3.1.4. Jointure basée sur plusieurs colonnes"

#: datatable-joinsMA695.Rmd:block 59 (paragraph)
msgid ""
"So far we have just joined `data.table` base on 1 column, but it's "
"important to know that the package can join tables matching several columns."
msgstr ""
"Jusqu'à présent, nous avons réalisé les jointures en se basant sur une "
"colonne `data.table`, mais il est important de savoir que le package peut "
"joindre des tables en prenant en compte plusieurs colonnes."

#: datatable-joinsMA695.Rmd:block 60 (paragraph)
msgid ""
"To illustrate this, let's assume that we want to add the `tax_prop` from "
"`NewTax` to **update** the `Products` table."
msgstr ""
"Pour illustrer cela supposons que nous voulions ajouter `tax_prop` de "
"`NewTax` pour **mettre à jour** la table `Products`."

#: datatable-joinsMA695.Rmd:block 62 (header)
msgid "3.2. Inner join"
msgstr "3.2. Jointure interne"

#: datatable-joinsMA695.Rmd:block 63 (paragraph)
msgid ""
"Use this method if you need to combine columns from 2 tables based on one "
"or more references but ***keeping only rows matched in both tables***."
msgstr ""
"Utilisez cette méthode pour combiner les colonnes de deux tables en se "
"basant sur une ou plusieurs références mais ***en gardant seulement les "
"lignes sélectionnées dans les deux tables***."

#: datatable-joinsMA695.Rmd:block 64 (paragraph)
msgid ""
"To perform this operation we just need to add `nomatch = NULL` or `nomatch "
"= 0` to any of the prior join operations to return the same results."
msgstr ""
"Pour réaliser cette opération il suffit d'ajouter `nomatch = NULL` ou "
"`nomatch = 0` à l'une quelconque des opérations de jointure précédentes "
"pour renvoyer le même résultat."

#: datatable-joinsMA695.Rmd:block 66 (paragraph)
msgid ""
"Despite both tables have the same information, they present some relevant "
"differences:"
msgstr ""
"Même si les deux tables contiennent la même information, il existe quelques "
"différences importantes :"

#: datatable-joinsMA695.Rmd:block 67 (unordered list)
msgid "They present different order for their columns"
msgstr "Elles présentent un ordre différent pour leurs colonnes"

#: datatable-joinsMA695.Rmd:block 67 (unordered list)
msgid "They have some name differences on their columns names:"
msgstr ""
"Elles comportent certaines différences de noms dans le nom des colonnes :"

#: datatable-joinsMA695.Rmd:block 67 (unordered list)
msgid ""
"The `id` column of first table has the same information as the `product_id` "
"in the second table."
msgstr ""
"La colonne `id` de la première table contient les mêmes informations que "
"`product_id` de la seconde table."

#: datatable-joinsMA695.Rmd:block 67 (unordered list)
msgid ""
"The `i.id` column of first table has the same information as the `id` in "
"the second table."
msgstr ""
"La colonne `i.id` de la première table a les mêmes informations que `id` de "
"la seconde table."

#: datatable-joinsMA695.Rmd:block 68 (header)
msgid "3.3. Not join"
msgstr "3.3. Non jointure"

#: datatable-joinsMA695.Rmd:block 69 (paragraph)
msgid ""
"This method **keeps only the rows that don't match with any row of a second "
"table**."
msgstr ""
"Cette méthode extrait **ne garde que les lignes qui ne correspondent pas à "
"n'importe quelle ligne d'une seconde table**."

#: datatable-joinsMA695.Rmd:block 70 (paragraph)
msgid ""
"To apply this technique we just need to negate (`!`) the table located on "
"the `i` argument."
msgstr ""
"Pour appliquer cette technique il suffit d'utiliser la négation  (`!`) sur "
"la table qui se trouve dans l'argument `i` ."

#: datatable-joinsMA695.Rmd:block 72 (paragraph)
msgid ""
"As you can see, the result only has 'banana', as it was the only product "
"that is not present in the `ProductReceived` table."
msgstr ""
"Comme on peut le voir, le résultat ne comporte que les bananes car c'est le "
"seul produit qui ne figure pas dans la table `ProductReceived`."

#: datatable-joinsMA695.Rmd:block 74 (paragraph)
msgid ""
"In this case, the operation returns the row with `product_id = 6,` as it is "
"not present on the `Products` table."
msgstr ""
"Dans ce cas l'opération renvoie la ligne de `product_id = 6,` car il ne "
"figure pas dans la table `Products`."

#: datatable-joinsMA695.Rmd:block 75 (header)
msgid "3.4. Semi join"
msgstr "3.4. Semi jointure"

#: datatable-joinsMA695.Rmd:block 76 (paragraph)
msgid ""
"This method extract **keeps only the rows that match with any row in a "
"second table** without combining the column of the tables."
msgstr ""
"Cette méthode extrait **ne garde que les lignes qui correspondent à "
"n'importe quelle ligne d'une seconde table** sans combiner la colonne des "
"tables."

#: datatable-joinsMA695.Rmd:block 77 (paragraph)
msgid ""
"It's very similar to subset as join, but as in this time we are passing a "
"complete table to the `i` we need to ensure that:"
msgstr ""
"En tant que jointure ceci est très similaire au sous-ensemble, mais comme "
"cette fois nous passons une table complète dans `i` nous devons vérifier "
"que : "

#: datatable-joinsMA695.Rmd:block 78 (unordered list)
msgid ""
"Any row in the `x` table is duplicated due row duplication in the table "
"passed to the `i` argument."
msgstr ""
"Chaque ligne de la table `x` est dupliquée à cause de la duplication des "
"lignes dans la table passée dans l'argument `i`."

#: datatable-joinsMA695.Rmd:block 78 (unordered list)
msgid "All the renaming rows from `x` should keep the original row order."
msgstr ""
"Toutes les lignes renommées de `x` doivent conserver l'ordre originel des "
"lignes."

#: datatable-joinsMA695.Rmd:block 79 (paragraph)
msgid "To make this, you can apply the following steps:"
msgstr "Pour faire ceci, suivez les étapes ci-après :"

#: datatable-joinsMA695.Rmd:block 80 (ordered list)
msgid ""
"Perform a **inner join** with `which = TRUE` to save the row numbers "
"related to each matching row of the `x` table."
msgstr ""
"Réaliser une **jointure interne** avec `which = TRUE` pour sauvegarder les "
"numéros de ligne liés à chaque ligne sélectionnée de la table `x` ."

#: datatable-joinsMA695.Rmd:block 82 (ordered list)
msgid "Select and sort the unique rows ids."
msgstr "Sélectionner et trier les id uniques de lignes."

#: datatable-joinsMA695.Rmd:block 84 (ordered list)
msgid "Selecting the `x` rows to keep."
msgstr "Sélectionner les `x` rangées à garder."

#: datatable-joinsMA695.Rmd:block 86 (header)
msgid "3.5. Left join"
msgstr "3.5. Jointure gauche"

#: datatable-joinsMA695.Rmd:block 87 (paragraph)
msgid ""
"Use this method if you need to combine columns from 2 tables based on one "
"or more references but ***keeping all rows present in the table located on "
"the left***."
msgstr ""
"Utilisez cette méthode pour combiner les colonnes de deux tables en se "
"basant sur une ou plusieurs références mais ***en gardant toutes les lignes "
"présentes dans la table située à gauche***."

#: datatable-joinsMA695.Rmd:block 88 (paragraph)
msgid ""
"To perform this operation, we just need to **exchange the order between "
"both tables** and the columns names in the `on` argument."
msgstr ""
"Pour réaliser cette opération, il suffit d'**échanger l'ordre entre les "
"deux tables** ainsi que le nom des colonnes dans l'argument `on`."

#: datatable-joinsMA695.Rmd:block 90 (paragraph)
msgid "Here some important considerations:"
msgstr "Voici des éléments importants à prendre en compte :"

#: datatable-joinsMA695.Rmd:block 91 (unordered list)
msgid ""
"The *first group* of columns now comes from the `ProductReceived` table as "
"it is the `x` table."
msgstr ""
"Le *premier groupe* de colonnes vient maintenant de la table "
"`ProductReceived` car il est la table `x` ."

#: datatable-joinsMA695.Rmd:block 91 (unordered list)
msgid ""
"The *second group* of columns now comes from the `Products` table as it is "
"the `i` table."
msgstr ""
"Le *second groupe* de colonnes vient maintenant de la table `Products` car "
"il est la table `i` ."

#: datatable-joinsMA695.Rmd:block 91 (unordered list)
msgid "It didn't add the prefix `i.` to any column."
msgstr "Le préfixe `i.` n'a été ajouté à aucune colonne."

#: datatable-joinsMA695.Rmd:block 91 (unordered list)
msgid ""
"All rows from in the `i` table were kept as we never received any banana "
"but row is still part of the results."
msgstr ""
"Toutes les lignes de la table `i` ont été gardées car nous n'avons jamais "
"reçu de bananes et la ligne fait toujours partie des résultats."

#: datatable-joinsMA695.Rmd:block 91 (unordered list)
msgid ""
"The row related to `product_id = 6` is no part of the results any more as "
"it is not present in the `Products` table."
msgstr ""
"La ligne concernant `product_id = 6` ne fait plus partie des résultats car "
"elle n'est pas présente dans la table `Products`."

#: datatable-joinsMA695.Rmd:block 92 (header)
msgid "3.5.1. Joining after chain operations"
msgstr "3.5.1. Jointure après des opérations sur les chaînes"

#: datatable-joinsMA695.Rmd:block 93 (paragraph)
msgid ""
"One of the key features of `data.table` is that we can apply several "
"operations before saving our final results by chaining brackets."
msgstr ""
"Une des fonctionnalités clé de `data.table` est que l'on peut appliquer "
"plusieurs opérations en chaînant les crochets, avant d'enregistrer le "
"résultat final."

#: datatable-joinsMA695.Rmd:block 95 (paragraph)
msgid ""
"So far, if after applying all that operations **we want to join new columns "
"without removing any row**, we would need to stop the chaining process, "
"save a temporary table and later apply the join operation."
msgstr ""
"Jusqu'à présent, si après avoir exécuté toutes ces opérations **nous "
"souhaitons joindre de nouvelles colonnes sans supprimer aucune ligne**, il "
"faut arrêter le processus de chaînage, sauvegarder dans une table "
"temporaire puis effectuer ultérieurement l'opération de jointure."

#: datatable-joinsMA695.Rmd:block 96 (paragraph)
msgid ""
"To avoid that situation, we can use special symbols `.SD`, to apply a "
"**right join based on the changed table**."
msgstr ""
"Pour éviter cette situation, nous pouvons utiliser le symbole spécial `."
"SD`, pour appliquer une **jointure droite en fonction de la table "
"modifiée**."

#: datatable-joinsMA695.Rmd:block 98 (header)
msgid "3.6. Many to many join"
msgstr "3.6. Jointure de plusieurs à plusieurs"

#: datatable-joinsMA695.Rmd:block 99 (paragraph)
msgid ""
"Sometimes we want to join tables based on columns with **duplicated `id` "
"values** to later perform some transformations later."
msgstr ""
"Sometimes we want to join tables based on columns with **duplicated `id` "
"values** to later perform some transformations later."

#: datatable-joinsMA695.Rmd:block 100 (paragraph)
msgid ""
"To illustrate this situation let's take as an example the `product_id == "
"1L`, which have 4 rows in our `ProductReceived` table."
msgstr ""
"Pour illustrer cette situation, prenons par exemple le `product_id == 1L`, "
"qui a quatre lignes dans notre table `ProductReceived` ."

#: datatable-joinsMA695.Rmd:block 102 (paragraph)
msgid "And 4 rows in our `ProductSales` table."
msgstr "Et quatre rangées dans notre table `ProductSales`."

#: datatable-joinsMA695.Rmd:block 104 (paragraph)
msgid ""
"To perform this join we just need to filter `product_id == 1L` in the `i` "
"table to limit the join just to that product and set the argument `allow."
"cartesian = TRUE` to allow combining each row from one table with every row "
"from the other table."
msgstr ""
"Pour réaliser cette jointure il nous suffit de filtrer `product_id == 1L` "
"dans la table `i` pour limiter la jointure uniquement à ce produit et "
"déclarer l'argument `allow.cartesian = TRUE` pour permettre la combinaison "
"de chaque ligne d'une table avec chaque ligne de l'autre table."

#: datatable-joinsMA695.Rmd:block 106 (paragraph)
msgid ""
"Once we understand the result, we can apply the same process for **all "
"products**."
msgstr ""
"Une fois que nous avons assimilé les résultats, nous pouvont appliquer le "
"même processus pour **tous les produits**."

#: datatable-joinsMA695.Rmd:block 108 (quote)
msgid ""
"`allow.cartesian` is defaulted to FALSE as this is seldom what the user "
"wants, and such a cross join can lead to a very large number of rows in the "
"result. For example, if Table A has 100 rows and Table B has 50 rows, their "
"Cartesian product would result in 5000 rows (100 * 50). This can quickly "
"become memory-intensive for large datasets."
msgstr ""
"`allow.cartesian` vaut par défaut FALSE car c'est ce que l'utilisateur a "
"souhaité, et une telle jointure croisée peut conduire à un très grand "
"nombre de lignes dans le résultat. Par exemple, si Table A possède 100 "
"lignes et Table B en a 50, leur produit cartésien sera 5000 lignes (100 * "
"50). Ce qui peut rapidement accroître la mémoire occupée pour de grands "
"ensembles de données."

#: datatable-joinsMA695.Rmd:block 109 (header)
msgid "3.6.1. Selecting one match"
msgstr "3.6.1. Selection d'une correspondance"

#: datatable-joinsMA695.Rmd:block 110 (paragraph)
msgid ""
"After joining the table we might find out that we just need to return a "
"single join to extract the information we need. In this case we have 2 "
"alternatives:"
msgstr ""
"Après avoir fait la jointure de la table, nous pourrions penser qu'on "
"aurait pu utiliser une seule jointure pour extraire les informations "
"nécessaires. Dans ce cas il y a deux alternatives :"

#: datatable-joinsMA695.Rmd:block 111 (unordered list)
msgid ""
"We can select the **first match**, represented in the next example by `id = "
"2`."
msgstr ""
"Nous pouvons sélectionner la **première correspondance**, représentée dans "
"l'exemple suivant par `id = 2`."

#: datatable-joinsMA695.Rmd:block 113 (unordered list)
msgid ""
"We can select the **last match**, represented in the next example by `id = "
"9`."
msgstr ""
"Nous pouvons sélectionner la **dernière correspondance**, représentée dans "
"l'exemple suivant par `id = 9`."

#: datatable-joinsMA695.Rmd:block 115 (header)
msgid "3.6.2. Cross join"
msgstr "3.6.2. Jointure croisée"

#: datatable-joinsMA695.Rmd:block 116 (paragraph)
msgid ""
"If you want to get **all possible row combinations** regardless of any "
"particular id column we can follow the next process:"
msgstr ""
"Si vous voulez obtenir **toutes les combinaisons possibles de lignes** "
"quelque soit l'id de colonne, vous  pouvez suivre le processus suivant :"

#: datatable-joinsMA695.Rmd:block 117 (ordered list)
msgid "Create a new column in both tables with a constant."
msgstr "Créer une nouvelle colonne dans les deux tables avec une constante."

#: datatable-joinsMA695.Rmd:block 119 (ordered list)
msgid ""
"Join both table based on the new column and remove it after ending the "
"process, as it doesn't have reason to stay after joining."
msgstr ""
"Joindre les deux tables en fonction de la nouvelle colonne et supprimer "
"cette dernnière à la fin de la manipulation parce qu'il n'y a pas de raison "
"pour la garder."

#: datatable-joinsMA695.Rmd:block 121 (header)
msgid "3.7. Full join"
msgstr "3.7. Jointure complète"

#: datatable-joinsMA695.Rmd:block 122 (paragraph)
msgid ""
"Use this method if you need to combine columns from 2 tables based on one "
"or more references ***without removing any row***."
msgstr ""
"Utilisez cette méthode pour combiner les colonnes de deux tables en se "
"basant sur une ou plusieurs références mais ***sans supprimer aucune "
"ligne***."

#: datatable-joinsMA695.Rmd:block 123 (paragraph)
msgid ""
"As we saw in the previous section, any of the prior operations can keep the "
"missing `product_id = 6` and the **soda** (`product_id = 4`) as part of the "
"results."
msgstr ""
"Comme vu dans la section précédente, toutes les opérations ci-avant peuvent "
"conserver le `product_id = 6` absent et le **soda** (`product_id = 4`) "
"comme faisant partie du résultat."

#: datatable-joinsMA695.Rmd:block 124 (paragraph)
msgid ""
"To save this problem, we can use the `merge` function even thought it is "
"lower than using the native `data.table`'s joining syntax."
msgstr ""
"Pour résoudre ce problème nous pouvons utiliser la fonction `merge` bien "
"qu'elle soit moins préférable à l'utilisation de la syntaxe de jointure "
"native de `data.table`."

#: datatable-joinsMA695.Rmd:block 126 (header)
msgid "4. Non-equi join"
msgstr "4. Jointure non équilibrée"

#: datatable-joinsMA695.Rmd:block 127 (paragraph)
msgid ""
"A non-equi join is a type of join where the condition for matching rows is "
"not based on equality, but on other comparison operators like <, >, <=, or "
">=. This allows for **more flexible joining criteria**. In `data.table`, "
"non-equi joins are particularly useful for operations like:"
msgstr ""
"Une jointure de non équivalence est un type de jointure où la condition "
"pour sélectionner les lignes n'est pas basée sur une égalité mais sur "
"d'autres opérateurs de comparaison tels que <, >, <=, ou >=. Ceci permet "
"des **critères plus flexibles de jointure**. Dans `data.table`, le "
"jointures non équivalentes sont particulièrement utiles pour les opérations "
"telles  que :"

#: datatable-joinsMA695.Rmd:block 128 (unordered list)
msgid "Finding the nearest match"
msgstr "Recherche de la correspondance la plus proche"

#: datatable-joinsMA695.Rmd:block 128 (unordered list)
msgid "Comparing ranges of values between tables"
msgstr "Comparaison d'intervalles de valeurs entre deux tables"

#: datatable-joinsMA695.Rmd:block 129 (paragraph)
msgid "It's a great alternative if after applying a right of inner join:"
msgstr ""
"C'est une alternative intéressante si elle est appliquée à droite d'une "
"jointure interne."

#: datatable-joinsMA695.Rmd:block 130 (unordered list)
msgid ""
"You want to decrease the number of returned rows based on comparing numeric "
"columns of different table."
msgstr ""
"Vous souhaitez diminuer le nombre de lignes renvoyées en fonction du "
"résultat de la comparaison des colonnes numériques de tables différentes."

#: datatable-joinsMA695.Rmd:block 130 (unordered list)
msgid ""
"You don't need to keep the columns from table `x`*(secondary data.table)* "
"in the final table."
msgstr ""
"Il n'est pas nécessaire de garder les colonnes de la table `x`*(data.table "
"secondaire)* dans la table finale."

#: datatable-joinsMA695.Rmd:block 131 (paragraph)
msgid ""
"To illustrate how this work, let's center over attention on how are the "
"sales and receives for product 2."
msgstr ""
"Pour illustrer le fonctionnement, concentrons-nous sur les promotions et "
"les réceptions de product 2."

#: datatable-joinsMA695.Rmd:block 133 (paragraph)
msgid ""
"If want to know, for example, if can find any receive that took place "
"before a sales date, we can apply the next code."
msgstr ""
"Si l'on veut savoir par exemple si quelque chose a été reçu avant la date "
"des promotions, nous pouvons utiliser le code suivant."

#: datatable-joinsMA695.Rmd:block 135 (paragraph)
msgid ""
"What does happen if we just apply the same logic on the list passed to `on`?"
msgstr ""
"Que se passe-t-il si nous appliquons simplement la même logique à la liste "
"passée à `on` ?"

#: datatable-joinsMA695.Rmd:block 136 (unordered list)
msgid ""
"As this opperation it's still a right join, it returns all rows from the "
"`i` table, but only shows the values for `id` and `count` when the rules "
"are met."
msgstr ""
"Comme cette opération est encore une jointure droite, elle renvoie toutes "
"les lignes de la table `i` , mais n'affiche que les valeurs de `id` et "
"`count` lorsque les règles sont vérifiées."

#: datatable-joinsMA695.Rmd:block 136 (unordered list)
msgid ""
"The date related `ProductReceivedProd2` was omited from this new table."
msgstr ""
"La date correspondant à `ProductReceivedProd2` a été omise de cette "
"nouvelle table."

#: datatable-joinsMA695.Rmd:block 138 (paragraph)
msgid ""
"Now, after applying the join, we can limit the results only show the cases "
"that meet all joining criteria."
msgstr ""
"Maintenant après avoir appliqué la jointure, nous pouvons limiter les "
"résultats pour n'afficher que les cas qui satisfont tous les critères de "
"jointure."

#: datatable-joinsMA695.Rmd:block 140 (header)
msgid "5. Rolling join"
msgstr "5. Jointure glissante"

#: datatable-joinsMA695.Rmd:block 141 (paragraph)
msgid ""
"Rolling joins are particularly useful in time-series data analysis. They "
"allow you to **match rows based on the nearest value** in a sorted column, "
"typically a date or time column."
msgstr ""
"Les jointures glissantes sont particulièrement utiles si vous faites des "
"analyses de données sur des séries temporelles. Elles permettent de "
"**prendre en compte les lignes basées sur la valeur la plus proche** dans "
"une colonne triée, typiquement une colonne avec une date ou un horodatage."

#: datatable-joinsMA695.Rmd:block 142 (paragraph)
msgid ""
"This is valuable when you need to align data from different sources **that "
"may not have exactly matching timestamps**, or when you want to carry "
"forward the most recent value."
msgstr ""
"C'est utile lorsque vous avez besoin d'aligner des données de sources "
"différentes **qui n'ont pas forcément les mêmes horodatages**, ou si vous "
"souhaitez continuer avec la valeur la plus récente."

#: datatable-joinsMA695.Rmd:block 143 (paragraph)
msgid ""
"For example, in financial data, you might use a rolling join to assign the "
"most recent stock price to each transaction, even if the price updates and "
"transactions don't occur at the exact same times."
msgstr ""
"Par exemple, avec des données financières, vous pourriez utiliser une "
"jointure glissante pour assigner la valeur la plus récente d'une action à "
"chaque transaction, même si les mises à jour du prix et les transactions ne "
"correspondent pas exactement aux mêmes instants."

#: datatable-joinsMA695.Rmd:block 144 (paragraph)
msgid ""
"In our supermarket example, we can use a rolling join to match sales with "
"the most recent product information."
msgstr ""
"Dans notre exemple de supermarché nous pouvons utiliser une jointure "
"glissante pour correspondre aux promotions avec les informations de produit "
"les plus récentes."

#: datatable-joinsMA695.Rmd:block 145 (paragraph)
msgid ""
"Let's assume that the price for Bananas and Carrots changes at the first "
"date of each month."
msgstr ""
"Supposons que le prix des bananes et des carottes change le premier jour de "
"chaque mois."

#: datatable-joinsMA695.Rmd:block 147 (paragraph)
msgid ""
"Now, we can perform a right join giving a different prices for each product "
"based on the sale date."
msgstr ""
"Maintenant nous pouvons réaliser une jointure droite en donnant un prix "
"différent à chaque produit en fonction de la date de promotion."

#: datatable-joinsMA695.Rmd:block 149 (paragraph)
msgid ""
"If we just want to see the matching cases we just need to add the argument "
"`nomatch = NULL` to perform an inner rolling join."
msgstr ""
"Si nous voulons simplement voir les cas de correspondance, il suffit "
"d'ajouter l'argument `nomatch = NULL` pour réaliser une jointure glissante "
"en interne."

#: datatable-joinsMA695.Rmd:block 151 (header)
msgid "7. Taking advange of joining speed"
msgstr "7. Avantage de la vitesse de jointure"

#: datatable-joinsMA695.Rmd:block 152 (header)
msgid "7.1. Subsets as joins"
msgstr "7.1. Sous-ensembles en tant que jointures"

#: datatable-joinsMA695.Rmd:block 153 (paragraph)
msgid ""
"As we just saw in the prior section the `x` table gets filtered by the "
"values available in the `i` table. Actually, that process is faster than "
"passing a Boolean expression to the `i` argument."
msgstr ""
"Comme nous venons de le voir, dans la section précédente la table `x` est "
"filtrée par les valeurs de la table `i` . Actuellement cette méthode est "
"plus rapide que de passer une expression booléenne dans l'argument `i`."

#: datatable-joinsMA695.Rmd:block 154 (paragraph)
msgid ""
"To filter the `x` table at speed we don't to pass a complete `data.table`, "
"we can pass a `list()` of vectors with the values that we want to keep or "
"omit from the original table."
msgstr ""
"Pour filtrer la table `x` rapidement nous ne passons pas la `data.table` "
"entière, nous pouvons passer une `list()` de vecteurs avec les valeurs de "
"la table originale que nous voulons garder ou omettre."

#: datatable-joinsMA695.Rmd:block 155 (paragraph)
msgid ""
"For example, to filter dates where the market received 100 units of bananas "
"(`product_id = 1`) or popcorn (`product_id = 3`) we can use the following:"
msgstr ""
"Par exemple pour filtrer les dates auxquelles le marché a reçu 100 unités "
"de bananes (`product_id = 1`) ou de popcorn (`product_id = 3`) nous pouvons "
"utiliser ceci :"

#: datatable-joinsMA695.Rmd:block 157 (paragraph)
msgid ""
"As at the end, we are filtering based on a join operation the code returned "
"a **row that was not present in original table**. To avoid that behavior, "
"it is recommended to always to add the argument `nomatch = NULL`."
msgstr ""
"Nous voici à la fin, nous filtrons le code **ligne absente dans la table "
"originale** renvoyé suite à la jointure. Pour éviter ce comportement il est "
"recommandé de toujours ajouter l'argument `nomatch = NULL`."

#: datatable-joinsMA695.Rmd:block 159 (paragraph)
msgid ""
"We can also use this technique to filter out any combination of values by "
"prefixing them with `!` to negate the expression in the `i` argument and "
"keeping the `nomatch` with its default value. For example, we can filter "
"out the 2 rows we filtered before."
msgstr ""
"Nous pouvons aussi utiliser cette technique pour filtrer toute combinaison "
"de valeurs en les préfixant avec `!` pour obtenir la négation de "
"l'expression dans l'argument `i` et en gardant le `nomatch` à sa valeur par "
"défaut. Par exemple nous pouvons filtrer les deux lignes filtrées "
"précédemment."

#: datatable-joinsMA695.Rmd:block 161 (paragraph)
msgid ""
"If you just want to filter a value for a single **character column**, you "
"can omit calling the `list()` function pass the value to been filtered in "
"the `i` argument."
msgstr ""
"Si vous voulez simplement filtrer une valeur pour une **colonne de "
"caractères** seule, vous pouvez ne pas appeler la fonction `list()` et "
"passer la valeur pour être filtrée dans l'argument `i`."

#: datatable-joinsMA695.Rmd:block 163 (header)
msgid "7.2. Updating by reference"
msgstr "7.2. Mise à jour par référence"

#: datatable-joinsMA695.Rmd:block 164 (paragraph)
msgid ""
"The `:=` operator in data.table is used for updating or adding columns by "
"reference. This means it modifies the original data.table without creating "
"a copy, which is very memory-efficient, especially for large datasets. When "
"used inside a data.table, `:=` allows you to **add new columns** or "
"**modify existing ones** as part of your query."
msgstr ""
"L'opérateur `:=` de data.table est utilisé pour mettre à jour ou ajouter "
"des colonnes par référence. Cela signifie qu'il modifie la data.table "
"originale sans créer de copie , ce qui est très efficace en termes de "
"mémoire, particulièrement avec les grands ensembles de données. Lorsqu'il "
"est utilisé à l'intérieur d'une data.table, `:=` permet d'**ajouter de "
"nouvelles colonnes** ou de **modifier des colonnes existantes** à "
"l'intérieur d'une même requête."

#: datatable-joinsMA695.Rmd:block 165 (paragraph)
msgid ""
"Let's update our `Products` table with the latest price from "
"`ProductPriceHistory`:"
msgstr ""
"Mettons à jour notre table `Products` avec le dernier prix connu de "
"`ProductPriceHistory` :"

#: datatable-joinsMA695.Rmd:block 167 (paragraph)
msgid "In this operation:"
msgstr "Dans cette opération :"

#: datatable-joinsMA695.Rmd:block 168 (unordered list)
msgid ""
"The function `copy` prevent that `:=` changes by reference the `Products` "
"table.s"
msgstr ""
"La fonction `copy` empêche que `:=` modifie par référence les tables "
"`Products`."

#: datatable-joinsMA695.Rmd:block 168 (unordered list)
msgid ""
"We join `Products` with `ProductPriceHistory` based on `id` and "
"`product_id`."
msgstr ""
"Nous réalisons la jointure de `Products` avec `ProductPriceHistory` en "
"fonction de `id` et de `product_id`."

#: datatable-joinsMA695.Rmd:block 168 (unordered list)
msgid ""
"We update the `price` column with the latest price from "
"`ProductPriceHistory`."
msgstr ""
"Nous mettons à jour la colonne `price` avec le prix le plus récent de "
"`ProductPriceHistory`."

#: datatable-joinsMA695.Rmd:block 168 (unordered list)
msgid ""
"We add a new `last_updated` column to track when the price was last changed."
msgstr ""
"Nous ajoutons une nouvelle colonne `last_updated` qui mémorisera la date du "
"dernier changement de prix."

#: datatable-joinsMA695.Rmd:block 168 (unordered list)
msgid ""
"The `by = .EACHI` ensures that the `tail` function is applied for each "
"product in `ProductPriceHistory`."
msgstr ""
"Le `by = .EACHI` assure que la fonction `tail` est appliquée à chaque "
"produit de `ProductPriceHistory`."

#: datatable-joinsMA695.Rmd:block 169 (header)
msgid "Reference"
msgstr "Référence"

#: datatable-joinsMA695.Rmd:block 170 (unordered list)
msgid ""
"*Understanding data.table Rolling Joins*: https://www.r-bloggers."
"com/2016/06/understanding-data-table-rolling-joins/"
msgstr ""
"*Comprendre les jointures glissantes de data.table*: https://www.r-bloggers."
"com/2016/06/understanding-data-table-rolling-joins/"

#: datatable-joinsMA695.Rmd:block 170 (unordered list)
msgid ""
"*Semi-join with data.table*: https://stackoverflow.com/questions/18969420/"
"perform-a-semi-join-with-data-table"
msgstr ""
"*Demi-jointure avec data.table*: https://stackoverflow.com/"
"questions/18969420/perform-a-semi-join-with-data-table"

#: datatable-joinsMA695.Rmd:block 170 (unordered list)
msgid ""
"*Cross join with data.table*: https://stackoverflow.com/questions/10600060/"
"how-to-do-cross-join-in-r"
msgstr ""
"*Jointure croisée avec with data.table*: https://stackoverflow.com/"
"questions/10600060/how-to-do-cross-join-in-r"

#: datatable-joinsMA695.Rmd:block 170 (unordered list)
msgid ""
"*How does one do a full join using data.table?*: https://stackoverflow.com/"
"questions/15170741/how-does-one-do-a-full-join-using-data-table"
msgstr ""
"*Comment réaliser une jointure complète à l'aide de data.table ?*: https://"
"stackoverflow.com/questions/15170741/how-does-one-do-a-full-join-using-data-"
"table"

#: datatable-joinsMA695.Rmd:block 170 (unordered list)
msgid ""
"*Enhanced data.frame*: https://rdatatable.gitlab.io/data.table/reference/"
"data.table.html"
msgstr ""
"*data.frame étendu*: https://rdatatable.gitlab.io/data.table/reference/data."
"table.html"
